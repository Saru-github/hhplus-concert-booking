 <aside>
💡 아래 명세를 잘 읽어보고, 서버를 구현합니다.

</aside>

## Description

- **`콘서트 예약 서비스`**를 구현해 봅니다.
- 대기열 시스템을 구축하고, 예약 서비스는 작업가능한 유저만 수행할 수 있도록 해야합니다.
- 사용자는 좌석예약 시에 미리 충전한 잔액을 이용합니다.
- 좌석 예약 요청시에, 결제가 이루어지지 않더라도 일정 시간동안 다른 유저가 해당 좌석에 접근할 수 없도록 합니다.

<aside>
🗓️ **Weekly Schedule Summary: 이번 챕터의 주간 일정 (금요일 오전 10시까지 제출)**

</aside>

### 6주차 과제

### **`STEP 11_기본`**

- 나의 시나리오에서 발생할 수 있는 동시성 이슈에 대해 파악하고 가능한 동시성 제어 방식들을 도입해보고 각각의 장단점을 파악한 내용을 정리 제출
    - 구현의 복잡도, 성능, 효율성 등
    - README 작성 혹은 외부 링크, 프로젝트 내의 다른 문서에 작성하였다면 README 에 링크 게재

### **`STEP 12_심화`**

- **DB Lock 을 활용한 동시성 제어 방식** 에서 해당 비즈니스 로직에서 적합하다고 판단하여 차용한 동시성 제어 방식을 구현하여 비즈니스 로직에 적용하고, 통합테스트 등으로 이를 검증하는 코드 작성 및 제출

### **`코치님 채점 중점 사항`**
DB락에 대해 더 깊게 파겠다:
- MySQL의 특징과, 그래서 Transaction Level 마다 발생하는 문제를 어떻게 해결했는지
- 같은 기능을 낙관적락, 비관적락 2개의 메소드로 구현해보고, 낙관적락: Retry 정도까지 구현
- 각각을 테스트해보고, 낙관적락: Retry해서 성공하는걸 보기, 비관적락: 진짜 1개만 성공하는지 보기
- 동시에 보내는 요청수를 늘려서 (1000개..), 어떤 문제가 생기는지 조사해보기

### STEP 11

# 동시성 제어 방식 보고서

## 1. 동시성 문제 개요
다중 트랜잭션이 특정 자원에 동시에 접근할 때 예상치 못한 데이터 변경이 발생할 수 있다. 이를 방지하기 위해 적절한 동시성 제어 방식을 도입하여 성능과 데이터 무결성을 모두 확보하는 것이 중요하다.

### 트랜잭션 격리 수준과 MySQL의 특징

- **트랜잭션 격리 수준**
    - **Uncommitted Read** ( 커밋되지 않은 읽기 )
        - 다른 트랜잭션에서 커밋되지 않은 데이터에도 접근할 수 있게 해주는 격리 수준
        - `DirtyRead` - 커밋되지 않은 트랜잭션에 접근해 아직 정상 반영되지 않은 데이터를 읽는 현상( 해당 데이터는 롤백되어 없어질 수도 있다 )
    - **Committed Read** ( 커밋된 읽기 )
        - 다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 해주는 격리 수준
        - `Non-Repeatable Read` - 하나의 트랜잭션에서 동일한 SELECT 쿼리를 실행했을 때 커밋 전의 데이터, 커밋 된 후의 데이터가 읽히면서 다른 결과가 조회되는 현상
    - **Repeatable Read** ( 반복 가능한 읽기 )
        - 커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준
        - **MVCC** 를 통해 Undo 로그를 기반으로 동일한 데이터가 조회되도록 보장 ( Non-Repeatable Read 문제 해결 )
        - 이를 지원하지 않는 DB (e.g. OracleDB ) 에서는 배타 락을 이용해 문제를 해결
        - `Phantom Read` - 하나의 트랜잭션 내에서 동일한 SELECT 쿼리의 결과 레코드 수가 달라지는 현상
            
            <aside>
            💡 MySQL 에서는 Phantom Read 가 발생하지 않음
            → InnoDB 엔진에 의해 `select ~ for update` 구문을 지원, Next Key Lock 형태의 배타락을 지원하기 때문
            
            </aside>
            
    - **Serealizable**
        - 모든 트랜잭션을 순차적으로 실행시키는 격리 수준
        - 트랜잭션이 서로 끼어들 수 있는 상황이 없으므로 데이터의 부정합 문제는 발생하지 않음
        - 위 특성 때문에 트랜잭션이 동기적으로 처리되면서 처리속도 저하가 발생
        - 트랜잭션이 개입하려는 시도 ( e.g. shared Lock 으로 조회 후 Update 하려고 하는 경우 )  대기상태가 되므로 데드락 문제가 발생함

#### MVCC (Multi-Version Concurrency Control)
> - `개념`: MVCC는 다중 버전 동시성 제어로, 트랜잭션 간의 데이터 충돌 없이 데이터의 여러 버전을 동시에 유지하여 읽기 작업과 쓰기 작업의 충돌을 피하는 방법.
> - `구현`: MVCC에서는 데이터를 변경할 때, 기존 데이터를 즉시 삭제하거나 덮어쓰지 않고 새로운 버전을 생성.
각 트랜잭션은 자신의 작업이 시작된 시점의 데이터 버전을 유지하면서 작업을 진행.
이를 통해 읽기 트랜잭션과 쓰기 트랜잭션이 동시에 수행될 수 있으며, 읽기 작업은 자신의 트랜잭션 시점의 데이터를 볼 수 있어 충돌이 발생하지 않는다.
> - `특징`:
>   - Read Consistency: 트랜잭션이 시작된 시점의 데이터 버전을 사용해 일관된 결과를 제공한다.
>   - 성능 향상: 읽기와 쓰기를 구분해 충돌을 방지함으로써 트랜잭션의 동시성을 크게 개선할 수 있다.
>   - Garbage Collection: 오래된 데이터 버전은 이후에 삭제되거나 정리.
> - `장점`: 
>   - 읽기 트랜잭션이 락 없이 작업할 수 있어 성능이 높고, 높은 동시성을 제공. 
>   - 데이터 충돌이 적은 경우 성능 향상이 크며, 읽기 작업이 많은 시스템에서 매우 유용하다.
> - `단점`: 데이터 버전을 관리하는 오버헤드가 발생하며, 자주 변경되는 데이터에 대해 오래된 버전을 유지하면 스토리지 사용이 증가한다.


- MySQL의 기본 트랜잭션 격리 수준은 `REPEATABLE READ`. 
- `REPEATABLE READ`는 일관성 유지에 유리하지만, 팬텀 리드(phantom read) 문제를 해결하지 못할 수 있으나 MySQL 의 경우 이부분이 해결 됨.
- 이를 해결하기 위해 InnoDB 스토리지 엔진에서는 Gap Lock을 활용하며, 성능이 필요한 경우 `READ COMMITTED` 수준으로 낮출 수 있다.

## 2. 동시성 제어 방식 비교

| 제어 방식                | 개념                                                                                             | 구현 방식                          | 장점                               | 단점                                         | 구현 복잡도 | 재시도 필요성 |
|-------------------------|------------------------------------------------------------------------------------------------|------------------------------------|----------------------------------|----------------------------------------------|------------|--------------|
| **비관적 락 (Pessimistic Lock)** | 데이터 접근 전부터 충돌 가능성을 고려하여 미리 락을 설정하는 방식 <br> 락이 설정되면 다른 트랜잭션은 락 해제 전까지 접근이 제한됨.                  | `SELECT FOR UPDATE`(X-LOCK) 사용  | 데이터 무결성 보장                  | 대기 시간이 길어져 대량 트래픽에서 성능 저하 발생 | 하         | 없음           |
| **낙관적 락 (Optimistic Lock)**   | 데이터 충돌이 적다고 가정하고, 갱신 시점에 충돌 여부를 체크. <br> Version 또는 Timestamp 필드를 사용해 충돌 발생 시 트랜잭션을 중단 또는 재시도. | `@Version` 필드와 `CAS` 활용      | 성능이 높고 고가용성 환경에서 확장성 우수 | 충돌 시 재시도 로직으로 인해 일시적 성능 저하 발생 | 중         | 있음           |
| **분산 락 (Distributed Lock)**    | 여러 인스턴스 또는 서버가 동일 자원에 접근하는 경우 중앙 락 관리자를 통해 락을 분산 관리.                                           | Redis, ZooKeeper, etcd 등         | 여러 서버 간 일관성 유지 가능       | 락 관리자의 성능과 가용성에 의존, 네트워크 지연 발생 가능 | 상         | 있음 (환경에 따라 다름) |

#### S-LOCK (Shared Lock) vs. X-LOCK (Exclusive Lock)
1. S-LOCK (Shared Lock)

>- `개념`: 데이터를 읽는 트랜잭션이 설정하는 잠금으로, 다른 트랜잭션이 동일한 데이터를 읽는 것은 허용되지만, 쓰기 작업은 허용X.
>- `특징`: 여러 트랜잭션이 동시에 같은 데이터에 S-LOCK을 걸 수 있어, 동시에 여러 트랜잭션이 읽기 작업을 수행할 수 있다.
>- `주요 사용 상황`: 데이터 조회 쿼리나 레포트 생성 작업과 같은 읽기 전용 작업에서 사용.

2. X-LOCK (Exclusive Lock)

>- `개념`: 데이터를 쓰거나 수정하는 트랜잭션이 설정하는 잠금으로, 해당 데이터에 대해 다른 트랜잭션이 읽기와 쓰기 모두 접근할 수 없다.
>- `특징`: X-LOCK이 설정된 데이터는 다른 트랜잭션이 접근하려면 잠금 해제가 완료될 때까지 대기해야 한다.
>- `주요 사용 상황`: INSERT, UPDATE, DELETE 등 데이터 변경 작업에서 사용되며, SELECT FOR UPDATE를 사용할 경우에도 X-LOCK이 걸려 다른 트랜잭션에서 접근할 수 없다.

JPA 사용시 JpaRepository 에
@Lock(LockModeType.PESSIMISTIC_WRITE) 어노테이션을 사용하여
X-LOCK 을 통한 비관적 락을 이용할 수 있다.

#### CAS (Compare-And-Swap)

>- `개념`: CAS는 데이터의 버전이나 특정 값이 예상하는 값과 일치하는지 확인한 후, 일치할 때만 값을 업데이트하는 방식. 
> 이 방법은 트랜잭션을 재시도하는 형태의 낙관적 락(Optimistic Lock) 구현 방식으로 많이 사용함.
> - `구현`:
일반적으로 DB 컬럼에 version 필드나 timestamp 필드를 추가한다.
데이터를 읽어온 후 수정할 때, DB의 버전 필드가 이전 읽어온 버전과 동일한지 확인.
만약 동일하다면 값이 변하지 않았음을 의미하므로 안전하게 업데이트 작업을 수행하고, 동일하지 않다면 트랜잭션을 중단하고 재시도한다.
> - `장점`: 
> 충돌이 낮은 환경에서 성능이 높아, 주로 고성능을 요구하는 읽기 작업에서 유용.
락을 설정하지 않아도 되므로 대기 시간이 없고, 시스템 리소스에 부담을 덜 주게 된다.
> - `단점`: 
충돌이 잦은 환경에서는 지속적인 트랜잭션 재시도로 인해 성능 저하가 발생할 수 있다.

## 3. 시나리오별 동시성 제어 방식 적용 및 타당성 검토

### 1) 유저 포인트 충전, 사용 - 낙관적 락 적용

- **적용 이유**: 포인트 충전은 동시에 다수의 사용자가 한 유저에 대해 충전하는 경우가 드물고 충돌 빈도가 낮다. 
처음에는 다중창 등 모든 요청이 처리 되어야 한다고 생각해서 비관적 락이 재시도 하지 않는 방법으로 적합하다고 생각 하였으나,
따닥이슈, 혹은 여러창을 열어 충전 및 사용 하는것은 어뷰징 행위라고 생각하여 retry 없는 낙관적 락을 사용하기로 결정.
- **장점**: 충돌 빈도가 낮아 충전 작업의 성능이 높아진다.
- **단점**: 충돌이 발생할 경우 재시도 로직이 적용되어 일시적 성능 저하가 발생할 수 있다.

> 포인트 충전에 대한 동시성 제어 미설정
![포인트_동시성제어 실패](https://velog.velcdn.com/images/saruru/post/2aaa66f7-ecb9-4f02-9052-021af6ca679f/image.png)

> 포인트 충전에 대한 비관적 LOCK 설정
> ![포인트_비관적락_성공](https://velog.velcdn.com/images/saruru/post/a8b777c1-f0e2-49e1-99ab-bb1ea83fdf90/image.png)
> 따닥 이슈, 다중창 이슈시 모두 충전 되어야 한다면 비관적 LOCK 이 유리.

> 포인트 충전에 대한 낙관적 LOCK 설정 시 예외 발생
> ![포인트_낙관적락_예외발생](https://velog.velcdn.com/images/saruru/post/0462c0b8-5c09-43f2-aaaf-f5e4b50cc225/image.png)

> 포인트 충전에 대한 낙관적 LOCK 결과
> ![포인트_낙관적락_예외결과](https://velog.velcdn.com/images/saruru/post/c596d955-befe-40fb-8212-1e0886e8678f/image.png)

> 포인트 충전에 대한 낙관적 LOCK 10 재시도
![포인트_낙관적락_10회재시도](https://velog.velcdn.com/images/saruru/post/1f849d46-5403-4c7a-9467-1cf95a18f741/image.png)

> 포인트 충전에 대한 낙관적 LOCK 20 재시도
![포인트_낙관적락_20회재시도](https://velog.velcdn.com/images/saruru/post/9d41f5bf-cad3-4fb1-b8dd-35988276f035/image.png)

 결론: 동시성 이슈를 어뷰징으로 본다면 낙관적락, 무조건 전부 충전 or 사용으로 본다면 비관적락이 맞는 전략으로 보인다.
 다만 낙관적락으로 따닥 혹은 다중창 이슈를 해결 하기위해서는 유니크 값을 이용한 제어가 필요한데, 스레드별 다중 요청의 대한 처리의 갯수와
 개념 적으로 볼때 추후 낙관적 락을 선택한다면 적절한 조치가 필요 할 것으로 보인다.


### 2) 좌석 점유 - 비관적 락 적용

- **적용 이유**: 다수의 사용자가 동일 좌석을 점유하려는 가능성이 높아 충돌 확률이 크다. 1명의 유저만 성공하고 2번째 요청부터는 순차적으로 실패
- **장점**: 충돌이 높은 상황에서 데이터 무결성을 보장.
- **단점**: 트랜잭션 대기 시간이 증가하며, 특히 트래픽이 많을 경우 성능 저하가 발생한다. 이후에 분산락을 통해 이러한 단점을 보완할 예정

> 좌석 점유에 대한 동시성 제어 미설정
![좌석 동시성 제어 실패](https://velog.velcdn.com/images/saruru/post/4aef2bc9-8735-4b34-9a8f-1035c1a5b282/image.png)

> 좌석 점유에 대한 낙관적 LOCK 설정
![좌석_낙관적락_동시성](https://velog.velcdn.com/images/saruru/post/783be35c-9c72-430e-9af4-a06e1848bf27/image.png)

> 좌석 점유에 대한 비관적 LOCK 설정
![좌석_비관적락_동시성](https://velog.velcdn.com/images/saruru/post/67df1c84-5ed7-4b69-a172-3379c8344b6a/image.png)

좌석점유시 첫번째 좌석에 대한 점유가 발생한다면
뒤에 모든 좌석은 실패로 끝이 나면 된다.
게다가 경합 상황이 많기 때문에 데이터 정합성을 위하여 비관적락을 사용한다.

### 3) 결제 - 미적용, 유저포인트 비관적락 사용시 락 획득필요

- **적용 하지 않은 이유**: 결제 시 잔액을 검증한 후 사용 및 예약확정 하는 작업으로, 무결성이 보장되어야 하나, 유저 포인트 부분에서 낙관적락을 적용할 경우
결제또한 정상적으로 1번만 성공하는 상황이 나왔다.
정확한 이유를 찾지 못하였으나 낙관적락으로 성공한 1번을 제외 한 모두가 실패케이스로 예외가 발생하게 되고, 락을 획득한 1번의 요청만이
끝까지 성공해서 그런것 아닌가 하는 유추를 해본다. 
만약 비관적락을 통하여 다중창일 때 모든 요청에 대한 포인트 충전을 가능하게 한다면, 임시 예약 -> 결제완료 시에도 락 부여가 필요할 것이라고 판단하였다.
이경우 임시예약된 concertBooking Entity 조회 혹은 Version 정보로 비관 or 낙관적 락을 따로 획득 해 주어야 한다.
아래는 채택하지는 않았지만, 테스트한 결과이며 3경우 모두 비관적락 사용시 성능이 어느정도 유의미한 저하가 보였다.

결제에 대한 낙관적락
![결제_낙관](https://velog.velcdn.com/images/saruru/post/7ae54089-5d59-4f91-96b4-5843f7b12b57/image.png)

결제에 대한 비관적락
![결제_비관](https://velog.velcdn.com/images/saruru/post/cb548193-88ad-4a6f-884e-9d9db6c95dcb/image.png)

세가지 락 모두 비관적락 일때 성능이 저하된다.
![비_비_비](https://velog.velcdn.com/images/saruru/post/b648e7d8-8794-43ea-809c-399a8f4a1b3d/image.png)


### 총평
비관적락을 이용하여 좌석점유 시 높은 자원 사용으로 인한 지연이 발생할 가능성이 높다.
현재 상태에서는 실제 높은 트래픽을 경험할 수 없으나, 대기열 까지 구현할 정도의 트래픽을 처리하기 위한 시스템이라면
높은 자원 사용으로 인한 많은 부하가 발생할 가능 성이 높기떄문에 분산락을 고려하는 것이 일반적인 방법 일 것이다.
하여 이번주차 까지 DB LOCK 을 이용한 분석 및 구현 이후 차주차부터는 Redis 를 이용한 분산락을 사용하여 로직을 개선할 예정.

