 <aside>
💡 아래 명세를 잘 읽어보고, 서버를 구현합니다.

</aside>

## Description

- **`콘서트 예약 서비스`**를 구현해 봅니다.
- 대기열 시스템을 구축하고, 예약 서비스는 작업가능한 유저만 수행할 수 있도록 해야합니다.
- 사용자는 좌석예약 시에 미리 충전한 잔액을 이용합니다.
- 좌석 예약 요청시에, 결제가 이루어지지 않더라도 일정 시간동안 다른 유저가 해당 좌석에 접근할 수 없도록 합니다.

## Requirements

- 아래 5가지 API 를 구현합니다.
    - 유저 토큰 발급 API
    - 예약 가능 날짜 / 좌석 API
    - 좌석 예약 요청 API
    - 잔액 충전 / 조회 API
    - 결제 API
- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.
- 동시성 이슈를 고려하여 구현합니다.
- 대기열 개념을 고려해 구현합니다.

## API Specs

1️⃣ **`주요` 유저 대기열 토큰 기능**

- 서비스를 이용할 토큰을 발급받는 API를 작성합니다.
- 토큰은 유저의 UUID 와 해당 유저의 대기열을 관리할 수 있는 정보 ( 대기 순서 or 잔여 시간 등 ) 를 포함합니다.
- 이후 대기열에 의해 **보호받는** 모든 API 는 위 토큰을 이용해 대기열 검증을 통과해야 이용 가능합니다.
- **내 대기번호를 조회하는 폴링용 API를 작성합니다.**

> 기본적으로 폴링으로 본인의 대기열을 확인한다고 가정하며, 다른 방안 또한 고려해보고 구현해 볼 수 있습니다.
> 

**2️⃣ `기본` 예약 가능 날짜 / 좌석 API**

- 예약가능한 날짜와 해당 날짜의 좌석을 조회하는 API 를 각각 작성합니다.
- 예약 가능한 날짜 목록을 조회할 수 있습니다.
- 날짜 정보를 입력받아 예약가능한 좌석정보를 조회할 수 있습니다.

> 좌석 정보는 1 ~ 50 까지의 좌석번호로 관리됩니다.
> 

3️⃣ **`주요` 좌석 예약 요청 API**

- 좌석 예약과 동시에 해당 좌석은 그 유저에게 약 5분간 임시 배정됩니다. ( 시간은 정책에 따라 자율적으로 정의합니다. )
- 날짜와 좌석 정보를 입력받아 좌석을 예약 처리하는 API 를 작성합니다.
- 만약 배정 시간 내에 결제가 완료되지 않는다면 좌석에 대한 임시 배정은 해제되어야 하며 임시배정 상태의 좌석에 대해 다른 사용자는 예약할 수 없어야 한다.

4️⃣ **`기본`**  **잔액 충전 / 조회 API**

- 결제에 사용될 금액을 API 를 통해 충전하는 API 를 작성합니다.
- 사용자 식별자 및 충전할 금액을 받아 잔액을 충전합니다.
- 사용자 식별자를 통해 해당 사용자의 잔액을 조회합니다.

5️⃣ **`주요` 결제 API**

- 결제 처리하고 결제 내역을 생성하는 API 를 작성합니다.
- 결제가 완료되면 해당 좌석의 소유권을 유저에게 배정하고 대기열 토큰을 만료시킵니다.

<aside>
💡 **KEY POINT**

</aside>

- 유저간 대기열을 요청 순서대로 정확하게 제공할 방법을 고민해 봅니다.
- 동시에 여러 사용자가 예약 요청을 했을 때, 좌석이 중복으로 배정 가능하지 않도록 합니다.

<aside>
🗓️ **Weekly Schedule Summary: 이번 챕터의 주간 일정 (금요일 오전 10시까지 제출)**

</aside>

### 6주차 과제

### **`STEP 11_기본`**

- 나의 시나리오에서 발생할 수 있는 동시성 이슈에 대해 파악하고 가능한 동시성 제어 방식들을 도입해보고 각각의 장단점을 파악한 내용을 정리 제출
    - 구현의 복잡도, 성능, 효율성 등
    - README 작성 혹은 외부 링크, 프로젝트 내의 다른 문서에 작성하였다면 README 에 링크 게재

### **`STEP 12_심화`**

- **DB Lock 을 활용한 동시성 제어 방식** 에서 해당 비즈니스 로직에서 적합하다고 판단하여 차용한 동시성 제어 방식을 구현하여 비즈니스 로직에 적용하고, 통합테스트 등으로 이를 검증하는 코드 작성 및 제출

### **`코치님 채점 중점 사항`**
DB락에 대해 더 깊게 파겠다:
- MySQL의 특징과, 그래서 Transaction Level 마다 발생하는 문제를 어떻게 해결했는지
- 같은 기능을 낙관적락, 비관적락 2개의 메소드로 구현해보고, 낙관적락: Retry 정도까지 구현
- 각각을 테스트해보고, 낙관적락: Retry해서 성공하는걸 보기, 비관적락: 진짜 1개만 성공하는지 보기
- 동시에 보내는 요청수를 늘려서 (1000개..), 어떤 문제가 생기는지 조사해보기

### STEP 11

# 동시성 제어 방식 보고서

## 1. 동시성 문제 개요
다중 트랜잭션이 특정 자원에 동시에 접근할 때 예상치 못한 데이터 변경이 발생할 수 있습니다. 이를 방지하기 위해 적절한 동시성 제어 방식을 도입하여 성능과 데이터 무결성을 모두 확보하는 것이 중요합니다.

### 트랜잭션 격리 수준과 MySQL의 특징

- **트랜잭션 격리 수준**
    - **Uncommitted Read** ( 커밋되지 않은 읽기 )
        - 다른 트랜잭션에서 커밋되지 않은 데이터에도 접근할 수 있게 해주는 격리 수준
        - `DirtyRead` - 커밋되지 않은 트랜잭션에 접근해 아직 정상 반영되지 않은 데이터를 읽는 현상( 해당 데이터는 롤백되어 없어질 수도 있다 )
    - **Committed Read** ( 커밋된 읽기 )
        - 다른 트랜잭션에서 커밋된 데이터에만 접근할 수 있게 해주는 격리 수준
        - `Non-Repeatable Read` - 하나의 트랜잭션에서 동일한 SELECT 쿼리를 실행했을 때 커밋 전의 데이터, 커밋 된 후의 데이터가 읽히면서 다른 결과가 조회되는 현상
    - **Repeatable Read** ( 반복 가능한 읽기 )
        - 커밋된 데이터만 읽을 수 있으며, 자신보다 빨리 수행된 트랜잭션에서 커밋한 데이터만 읽을 수 있는 격리 수준
        - **MVCC** 를 통해 Undo 로그를 기반으로 동일한 데이터가 조회되도록 보장 ( Non-Repeatable Read 문제 해결 )
        - 이를 지원하지 않는 DB (e.g. OracleDB ) 에서는 배타 락을 이용해 문제를 해결
        - `Phantom Read` - 하나의 트랜잭션 내에서 동일한 SELECT 쿼리의 결과 레코드 수가 달라지는 현상
            
            <aside>
            💡 MySQL 에서는 Phantom Read 가 발생하지 않음
            → InnoDB 엔진에 의해 `select ~ for update` 구문을 지원, Next Key Lock 형태의 배타락을 지원하기 때문
            
            </aside>
            
    - **Serealizable**
        - 모든 트랜잭션을 순차적으로 실행시키는 격리 수준
        - 트랜잭션이 서로 끼어들 수 있는 상황이 없으므로 데이터의 부정합 문제는 발생하지 않음
        - 위 특성 때문에 트랜잭션이 동기적으로 처리되면서 처리속도 저하가 발생
        - 트랜잭션이 개입하려는 시도 ( e.g. shared Lock 으로 조회 후 Update 하려고 하는 경우 )  대기상태가 되므로 데드락 문제가 발생함

#### MVCC (Multi-Version Concurrency Control)
> - `개념`: MVCC는 다중 버전 동시성 제어로, 트랜잭션 간의 데이터 충돌 없이 데이터의 여러 버전을 동시에 유지하여 읽기 작업과 쓰기 작업의 충돌을 피하는 방법입니다.
> - `구현`: MVCC에서는 데이터를 변경할 때, 기존 데이터를 즉시 삭제하거나 덮어쓰지 않고 새로운 버전을 생성합니다.
각 트랜잭션은 자신의 작업이 시작된 시점의 데이터 버전을 유지하면서 작업을 진행합니다.
이를 통해 읽기 트랜잭션과 쓰기 트랜잭션이 동시에 수행될 수 있으며, 읽기 작업은 자신의 트랜잭션 시점의 데이터를 볼 수 있어 충돌이 발생하지 않습니다.
> - `특징`:
>   - Read Consistency: 트랜잭션이 시작된 시점의 데이터 버전을 사용해 일관된 결과를 제공합니다.
>   - 성능 향상: 읽기와 쓰기를 구분해 충돌을 방지함으로써 트랜잭션의 동시성을 크게 개선할 수 있습니다.
>   - Garbage Collection: 오래된 데이터 버전은 이후에 삭제되거나 정리됩니다.
> - `장점`: 
>   - 읽기 트랜잭션이 락 없이 작업할 수 있어 성능이 높고, 높은 동시성을 제공합니다. 
>   - 데이터 충돌이 적은 경우 성능 향상이 크며, 읽기 작업이 많은 시스템에서 매우 유용합니다.
> - `단점`: 데이터 버전을 관리하는 오버헤드가 발생하며, 자주 변경되는 데이터에 대해 오래된 버전을 유지하면 스토리지 사용이 증가합니다.


- MySQL의 기본 트랜잭션 격리 수준은 `REPEATABLE READ`입니다. 
- `REPEATABLE READ`는 일관성 유지에 유리하지만, 팬텀 리드(phantom read) 문제를 해결하지 못할 수 있습니다.
- 이를 해결하기 위해 InnoDB 스토리지 엔진에서는 Gap Lock을 활용하며, 성능이 필요한 경우 `READ COMMITTED` 수준으로 낮출 수 있습니다.

## 2. 동시성 제어 방식 비교

| 제어 방식                | 개념                                                                                                  | 구현 방식                          | 장점                               | 단점                                         | 구현 복잡도 | 재시도 필요성 |
|-------------------------|-----------------------------------------------------------------------------------------------------|------------------------------------|----------------------------------|----------------------------------------------|------------|--------------|
| **비관적 락 (Pessimistic Lock)** | 데이터 접근 전부터 충돌 가능성을 고려하여 미리 락을 설정하는 방식입니다. <br> 락이 설정되면 다른 트랜잭션은 락 해제 전까지 접근이 제한됩니다. | `SELECT FOR UPDATE`(X-LOCK) 사용  | 데이터 무결성 보장                  | 대기 시간이 길어져 대량 트래픽에서 성능 저하 발생 | 하         | 없음           |
| **낙관적 락 (Optimistic Lock)**   | 데이터 충돌이 적다고 가정하고, 갱신 시점에 충돌 여부를 체크합니다. <br> Version 또는 Timestamp 필드를 사용해 충돌 발생 시 트랜잭션을 중단 또는 재시도합니다. | `@Version` 필드와 `CAS` 활용      | 성능이 높고 고가용성 환경에서 확장성 우수 | 충돌 시 재시도 로직으로 인해 일시적 성능 저하 발생 | 중         | 있음           |
| **분산 락 (Distributed Lock)**    | 여러 인스턴스 또는 서버가 동일 자원에 접근하는 경우 중앙 락 관리자를 통해 락을 분산 관리합니다.                       | Redis, ZooKeeper, etcd 등         | 여러 서버 간 일관성 유지 가능       | 락 관리자의 성능과 가용성에 의존, 네트워크 지연 발생 가능 | 상         | 있음 (환경에 따라 다름) |
명

#### S-LOCK (Shared Lock) vs. X-LOCK (Exclusive Lock)
1. S-LOCK (Shared Lock)

>- `개념`: 데이터를 읽는 트랜잭션이 설정하는 잠금으로, 다른 트랜잭션이 동일한 데이터를 읽는 것은 허용되지만, 쓰기 작업은 허용되지 않습니다.
>- `특징`: 여러 트랜잭션이 동시에 같은 데이터에 S-LOCK을 걸 수 있어, 동시에 여러 트랜잭션이 읽기 작업을 수행할 수 있습니다.
>- `주요 사용 상황`: 데이터 조회 쿼리나 레포트 생성 작업과 같은 읽기 전용 작업에서 사용됩니다.

2. X-LOCK (Exclusive Lock)

>- `개념`: 데이터를 쓰거나 수정하는 트랜잭션이 설정하는 잠금으로, 해당 데이터에 대해 다른 트랜잭션이 읽기와 쓰기 모두 접근할 수 없습니다.
>- `특징`: X-LOCK이 설정된 데이터는 다른 트랜잭션이 접근하려면 잠금 해제가 완료될 때까지 대기해야 합니다.
>- `주요 사용 상황`: INSERT, UPDATE, DELETE 등 데이터 변경 작업에서 사용되며, SELECT FOR UPDATE를 사용할 경우에도 X-LOCK이 걸려 다른 트랜잭션에서 접근할 수 없습니다.

JPA 사용시 JpaRepository 에
@Lock(LockModeType.PESSIMISTIC_WRITE) 어노테이션을 사용하여
X-LOCK 을 통한 비관적 락을 이용할 수 있습니다.
콘서트 좌석은 

#### CAS (Compare-And-Swap)

>- `개념`: CAS는 데이터의 버전이나 특정 값이 예상하는 값과 일치하는지 확인한 후, 일치할 때만 값을 업데이트하는 방식입니다. 
> 이 방법은 트랜잭션을 재시도하는 형태의 낙관적 락(Optimistic Lock) 구현 방식으로 많이 사용됩니다.
> - `구현`:
일반적으로 DB 컬럼에 version 필드나 timestamp 필드를 추가합니다.
데이터를 읽어온 후 수정할 때, DB의 버전 필드가 이전 읽어온 버전과 동일한지 확인합니다.
만약 동일하다면 값이 변하지 않았음을 의미하므로 안전하게 업데이트 작업을 수행하고, 동일하지 않다면 트랜잭션을 중단하고 재시도합니다.
> - `장점`: 
> 충돌이 낮은 환경에서 성능이 높아, 주로 고성능을 요구하는 읽기 작업에서 유용합니다.
락을 설정하지 않아도 되므로 대기 시간이 없고, 시스템 리소스에 부담을 덜 줍니다.
> - `단점`: 
충돌이 잦은 환경에서는 지속적인 트랜잭션 재시도로 인해 성능 저하가 발생할 수 있습니다.

## 3. 시나리오별 동시성 제어 방식 적용 및 타당성 검토

### 1) 유저 포인트 충전 - 낙관적 락 적용

- **적용 이유**: 포인트 충전은 동시에 다수의 사용자가 충전하는 경우가 드물고 충돌 빈도가 낮습니다. 
모든 요청이 처리되어야 하기 때문에 재작업 요청 보다는 비관적락을 이용해 순차적으로 모두 처리가능 하도록 했습니다.
- **장점**: 충돌 빈도가 낮아 충전 작업의 성능이 높아집니다.
- **단점**: 충돌이 발생할 경우 재시도 로직이 적용되어 일시적 성능 저하가 발생할 수 있습니다.

### 2) 좌석 점유 - 비관적 락 적용

- **적용 이유**: 다수의 사용자가 동일 좌석을 점유하려는 가능성이 높아 충돌 확률이 큽니다.
- **장점**: 충돌이 높은 상황에서 데이터 무결성을 보장합니다.
- **단점**: 트랜잭션 대기 시간이 증가하며, 특히 트래픽이 많을 경우 성능 저하가 발생합니다.


### 3) 결제 (유저 포인트 사용) - 비관적 락 적용

- **적용 이유**: 결제 시 잔액을 검증한 후 사용하는 작업으로, 무결성이 보장되어야 합니다.
- **장점**: 포인트 차감 요청의 데이터 일관성을 유지합니다.
- **단점**: 동시에 많은 트랜잭션이 발생할 경우 대기 시간과 성능 저하가 발생할 수 있습니다.

비관적락을 이용하여 좌석점유 시 높은 자원 사용으로 인한 지연이 발생할 가능성이 높습니다.
현재 상태에서는 실제 높은 트래픽을 경험할 수 없으나, 대기열 까지 구현할 정도의 트래픽을 처리하기 위한 시스템이라면
높은 자원 사용으로 인한 많은 부하가 발생할 가능 성이 높기떄문에
분산락을 고려하는 것이 일반적인 방법 일 것입니다.
하여 이번주차 까지 DB LOCK 을 이용한 분석 및 구현 이후 차주차부터는 Redis 를 이용한 분산락을 사용하여 로직을 개선할 예정입니다.

