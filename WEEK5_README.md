 <aside>
💡 아래 명세를 잘 읽어보고, 서버를 구현합니다.

</aside>

## Description

- **`콘서트 예약 서비스`**를 구현해 봅니다.
- 대기열 시스템을 구축하고, 예약 서비스는 작업가능한 유저만 수행할 수 있도록 해야합니다.
- 사용자는 좌석예약 시에 미리 충전한 잔액을 이용합니다.
- 좌석 예약 요청시에, 결제가 이루어지지 않더라도 일정 시간동안 다른 유저가 해당 좌석에 접근할 수 없도록 합니다.

## Requirements

- 아래 5가지 API 를 구현합니다.
    - 유저 토큰 발급 API
    - 예약 가능 날짜 / 좌석 API
    - 좌석 예약 요청 API
    - 잔액 충전 / 조회 API
    - 결제 API
- 각 기능 및 제약사항에 대해 단위 테스트를 반드시 하나 이상 작성하도록 합니다.
- 다수의 인스턴스로 어플리케이션이 동작하더라도 기능에 문제가 없도록 작성하도록 합니다.
- 동시성 이슈를 고려하여 구현합니다.
- 대기열 개념을 고려해 구현합니다.

## API Specs

1️⃣ **`주요` 유저 대기열 토큰 기능**

- 서비스를 이용할 토큰을 발급받는 API를 작성합니다.
- 토큰은 유저의 UUID 와 해당 유저의 대기열을 관리할 수 있는 정보 ( 대기 순서 or 잔여 시간 등 ) 를 포함합니다.
- 이후 대기열에 의해 **보호받는** 모든 API 는 위 토큰을 이용해 대기열 검증을 통과해야 이용 가능합니다.
- **내 대기번호를 조회하는 폴링용 API를 작성합니다.**

> 기본적으로 폴링으로 본인의 대기열을 확인한다고 가정하며, 다른 방안 또한 고려해보고 구현해 볼 수 있습니다.
> 

**2️⃣ `기본` 예약 가능 날짜 / 좌석 API**

- 예약가능한 날짜와 해당 날짜의 좌석을 조회하는 API 를 각각 작성합니다.
- 예약 가능한 날짜 목록을 조회할 수 있습니다.
- 날짜 정보를 입력받아 예약가능한 좌석정보를 조회할 수 있습니다.

> 좌석 정보는 1 ~ 50 까지의 좌석번호로 관리됩니다.
> 

3️⃣ **`주요` 좌석 예약 요청 API**

- 좌석 예약과 동시에 해당 좌석은 그 유저에게 약 5분간 임시 배정됩니다. ( 시간은 정책에 따라 자율적으로 정의합니다. )
- 날짜와 좌석 정보를 입력받아 좌석을 예약 처리하는 API 를 작성합니다.
- 만약 배정 시간 내에 결제가 완료되지 않는다면 좌석에 대한 임시 배정은 해제되어야 하며 임시배정 상태의 좌석에 대해 다른 사용자는 예약할 수 없어야 한다.

4️⃣ **`기본`**  **잔액 충전 / 조회 API**

- 결제에 사용될 금액을 API 를 통해 충전하는 API 를 작성합니다.
- 사용자 식별자 및 충전할 금액을 받아 잔액을 충전합니다.
- 사용자 식별자를 통해 해당 사용자의 잔액을 조회합니다.

5️⃣ **`주요` 결제 API**

- 결제 처리하고 결제 내역을 생성하는 API 를 작성합니다.
- 결제가 완료되면 해당 좌석의 소유권을 유저에게 배정하고 대기열 토큰을 만료시킵니다.

<aside>
💡 **KEY POINT**

</aside>

- 유저간 대기열을 요청 순서대로 정확하게 제공할 방법을 고민해 봅니다.
- 동시에 여러 사용자가 예약 요청을 했을 때, 좌석이 중복으로 배정 가능하지 않도록 합니다.

<aside>
🗓️ **Weekly Schedule Summary: 이번 챕터의 주간 일정 (금요일 오전 10시까지 제출)**

</aside>

### 5주차 과제

### **`DEFAULT`**

- 비즈니스 별 발생할 수 있는 에러 코드 정의 및 관리 체계 구축
- 프레임워크별 글로벌 에러 핸들러를 통해 예외 로깅 및 응답 처리 핸들러 구현
    - `spring` - **RestControllerAdvice**
    - `nestjs` - **ExceptionFilter**

### **`STEP 09`**

- 시스템 성격에 적합하게 Filter, Interceptor 를 활용해 기능의 관점을 분리하여 개선
- 모든 API 가 정상적으로 기능을 제공하도록 완성

> 각 시나리오별 요구사항 내에 정의된 기능은 정상적으로 동작할 수 있어야 합니다. 개선 및 최적화에 초점을 두는 것이 아닌, 추후 개선해나갈 수 있도록 동작하는 기능을 완성하는 것이 목적입니다.
> 

### **`STEP 10`**

- 시나리오별 동시성 **통합 테스트** 작성
- **Chapter 2** 회고록 작성

> DB Index , 대용량 처리를 위한 개선 포인트 등은 추후 챕터에서 진행하므로 목표는 `기능 개발의 완료` 로 합니다. 최적화 작업 등을 고려하는 것 보다 모든 기능을 정상적으로 제공할 수 있도록 해주세요. 특정 기능을 왜 이렇게 개발하였는지 합당한 이유와 함께 기능 개발을 진행해주시면 됩니다.
>

## 3~5 주차 회고

### 3주차

> 흔히 개발과 보고서는 뗄래야 뗄 수 없는 관계라고 할 수 있습니다. 잘 짜여진 기획과 계획은 개발의 속도와 비용 측면에서 큰 기여를 할 수 있다는 것을 알고 있었습니다. 하지만 실무에서 제대로 계획을 세워본 적이 없고, ERD도 거의 그리지 않아서 그저 JIRA를 통해 언제까지 마무리하겠다는 기한만 설정하고 개발했던 것 같습니다. 이번에 처음으로 ERD를 직접 그려보고, mermaid 문법을 익혀 시퀀스 다이어그램을 작성해보았습니다.
더욱 뜻깊었던 것은 3주차와 4주차에 접어들면서 점점 수정할 것도 많아지고 방향성을 잃을 때, 미리 ERD나 시퀀스 다이어그램을 잘 작성하거나 수정해 놓았더라면 개발의 큰 길라잡이가 되었을 것이라는 점이었습니다. 비록 많은 과제량을 즉각적으로 수정하거나 바로 반영하기는 어려웠지만, 이후 실무나 다른 프로젝트에서 이러한 기획 도구를 잘 활용해보고 싶다는 목표를 세웠습니다.

### 4주차
> 2주차는 콘서트의 전반적인 기능에 대해 직접 코드로 구현하는 시간이었습니다. 총 7~8개의 엔드포인트를 구현하였고, 클래스 단위로만 보면 약 50~60개의 새로운 클래스를 생성한 주인 것 같습니다. 사실 JPA나 TDD, 아키텍처를 생각하며 개발한 적이 없어서 1, 2주차까지 큰 애를 먹었는데, 조금 익숙해지면서 속된 말로 "뇌를 빼고" 코딩을 하게 되었습니다.
의외로 생각했던 대로 테스트 코드가 통과하는 모습을 보며 더욱 뿌듯함을 느꼈습니다. 물론 테스트 코드나 로직에 구멍이 발생하면 로직을 변경해야 했지만, 구현 자체에 재미를 느끼며 즐겁게 마무리한 주였습니다.

### 5주차
> 항상 로깅이나 검증의 영역이 어디인지 궁금했는데, 이번 주에 명확하게 풀린 것 같습니다. 로깅을 할 때는 필터를 사용하여 스프링 영역에 들어오기 전에 요청을, 나갈 때의 응답을 명확하게 알 수 있도록 구현했습니다. 이는 대부분의 상황에서 사용되기 때문에 필터에서 구현하였습니다. 인증의 경우 처음에는 AOP를 통해 어노테이션으로 구현할까 했지만, 코치님의 조언에 따라 Interceptor에서 좀 더 많은 로직을 실행하기 위해 빠르게 동작하도록 구현해보았습니다.
LOCK 관련해서도 주차가 지날수록 조금 더 이해가 되는 것 같습니다. 좌석 점유에 관해서는 조금 아쉬운 점이 있는데, 성공 또는 실패 관점에서 낙관적 락으로 구현했지만, 나중에 생각해보니 다수의 요청이 있을 수 있고 콘서트 예매의 특성상 데드락과 같은 관점에서도 조금 더 고려할 필요가 있을 것 같아 후에 비관적 락으로 변경할까 합니다.

### 총평
실제로 이렇게 빠르고 대규모의 개발을 해본 것이 참 오랜만인 것 같습니다. 새로운 기술을 적용하면서 코드를 작성하는 것도, 항상 궁금했던 예외 처리, 필터와 인터셉터, 동시성 처리, 락 등의 기술들에 대한 개념을 충분히 정리한 것 같아 매우 뜻깊은 주였습니다.
