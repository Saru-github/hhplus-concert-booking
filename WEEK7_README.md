 <aside>
💡 아래 명세를 잘 읽어보고, 서버를 구현합니다.

</aside>

## Description

- **`콘서트 예약 서비스`**를 구현해 봅니다.
- 대기열 시스템을 구축하고, 예약 서비스는 작업가능한 유저만 수행할 수 있도록 해야합니다.
- 사용자는 좌석예약 시에 미리 충전한 잔액을 이용합니다.
- 좌석 예약 요청시에, 결제가 이루어지지 않더라도 일정 시간동안 다른 유저가 해당 좌석에 접근할 수 없도록 합니다.

<aside>
🗓️ **Weekly Schedule Summary: 이번 챕터의 주간 일정 (금요일 오전 10시까지 제출)**

</aside>

### 7주차 과제

### **`STEP 13_기본`**

- 조회가 오래 걸리는 쿼리에 대한 캐싱, 혹은 Redis 를 이용한 로직 이관을 통해 성능 개선할 수 있는 로직을 분석하고 이를 합리적인 이유와 함께 정리한 문서 제출

### **`STEP 14_심화`**

- **이커머스 시나리오**
    
     Caching을 활용하여 부하를 최소화할 수 있는 비즈니스 로직을 파악해보고, 적절한 Caching Strategy를 적용하는 코드를 작성하여 제출
    
- **콘서트 예약 시나리오(대기열 인원수 제한 없음)**
    
    대기열 구현에 대한 설계를 진행하고, 설계한 내용과 부합하도록 적절하게 동작하는 대기열을 구현하여 제출
    
    - Redis, Queue, MQ 등 DB가 아닌 다른 수단을 활용해 대기열 개선 설계 및 구현 (”Nice to have”)

### STEP 13

# 캐싱 & Redis 보고서

- 캐시? 캐싱?
  - 캐시란 DB, 서버에 저장된 정보를 사용자 요청시 빠르게 전달 할 수 있도록 데이터를 임시로 저장하는 저장소이다.
  - 캐싱은 이러한 작업을 하는 행위를 의미한다.
- 캐시가 없으면 원본 데이터를 가지고 오게 된다. (Cache Miss)
- 캐시가 존재하면 빠르게 사용자에게 데이터를 전달하게 된다. (Cache Hit)

- 로컬캐시 vs 글로벌 캐시
  - 로컬 캐시는 쉽게 말해 특정 인스턴스 내에서만 즉 JVM 안에서 사용가능한 매우 빠른 캐시이다.
  - 글로벌 캐시는 서버간의 데이터를 공유하는 캐시로 하나의 동일 한 캐시 저장소로 여러 서버가 접근 하는 캐시이다.

현재 이들중 가장 핫한 글로벌 캐시를 구현하는 도구로 레디스를 가장 많이 사용하는 추세이다.

### 레디스 ???

레디스(Redis)는 인메모리 데이터 저장소로, 주로 빠른 데이터 접근이 필요한 곳에서 사용된다.
데이터베이스는 아니지만, 키-값 저장소로 데이터를 저장하고, 메모리 기반이라 속도가 빠르다. 
주로 캐시(Cache)나 메시지 큐(Message Queue) 시스템 등에서 널리 사용되며, 분산락 같은 동시성 제어에도 사용이 가능하다.

레디스를 이용한 캐싱 전략

1. 읽기 관점
- 지연 로딩 (Lazy Loading): 지연 로딩은 데이터를 실제로 필요할 때 로드하는 방식이다. 
레디스에서는 데이터를 처음 요청할 때, 캐시에 데이터가 없으면 DB에서 데이터를 조회해 온 후, 
레디스 캐시에 저장하고 이후 요청부터는 레디스에서 데이터를 바로 반환한다. 
이 방식은 처음 읽기 시에 DB에 부하가 걸릴 수 있지만, 반복되는 조회에서는 DB 부하를 줄일 수 있다.


- Read-Through 패턴: Read-Through 패턴은 캐시에서 데이터를 찾고, 없으면 DB에서 가져온 후 캐시에도 저장하는 방식이다. 
데이터가 캐시에 없으면 자동으로 DB를 조회하여 데이터를 로드하고 캐시에 저장한다. 
이 방식은 캐시가 데이터베이스의 확장선처럼 동작하게 만들어 데이터 일관성을 유지하는 데 유리하다.

2. 쓰기 관점

- Write-Through 패턴: Write-Through 패턴은 데이터를 DB와 레디스에 동시에 저장하는 방식이다. 
클라이언트가 데이터를 쓰면, DB와 레디스에 동시에 기록되며, 이 방식은 데이터 일관성을 높이지만 DB와 레디스에 각각 데이터를 업데이트하는 비용이 발생한다. 
DB > Redis로 데이터를 바로 저장하는 구조이다.


- Write-Back 패턴: Write-Back 패턴은 데이터를 레디스에 저장하고, 레디스가 주기적으로 데이터를 DB에 비동기 방식으로 업데이트하는 방식이다. 
이 방식은 성능 면에서 유리하지만, DB와 캐시 간의 일관성 문제를 해결하기 위해 주기적인 동기화가 필요하다. 
즉, 데이터를 먼저 레디스에 기록하고, 그 데이터는 비동기적으로 DB에 반영된다.


- Write-Around 패턴: Write-Around 패턴은 데이터를 직접 DB에 저장하고, 
DB에 저장된 데이터가 변경되면 변경된 데이터를 캡처하여 CDC(Changed Data Capture)를 통해 레디스에 반영하는 방식이다.
이 방식은 DB에 저장된 데이터를 캐시에 반영하는 과정에서 레디스의 성능을 극대화하고, DB에서의 데이터 일관성을 보장하는 데 유리하다. 
DB에 먼저 저장하고, 이후에 CDC로 변경된 데이터를 레디스에 업데이트한다.

### 그럼 콘서트 서비스에 적용해 보자.

먼저 레디스를 도입하여 캐싱을 가장 잘 활용할 수 있는 부분이 어딘지 생각해보자.
그 조건으로
1. 자주 자주 많은 조회 or 변화가 필요하다.
2. 도입시 성능 or 비용의 절감이 우수해야 한다.
3. 캐싱 히트율이 높아야한다.

사실 지금 이 서비스는 실제 이용자가 존재 하지도, 많은 부하나 row 수도 없다.
다만 미래적으로 봤을 때, 대기열을 구현한다거나 
보통 인기가수들의 콘서트표 같은 경우 몇십분만에 매진 되는 경우가 많다.

콘서트 일정조회, 유저 포인트조회, 결제등은
경쟁도 덜하고 비교적 큰 트래픽 부하를 일으킬 것 같지는 않았다.

따라서 기본적으로 가장 많은 트래픽 율을 자랑하고, 시시각각 변화하며
풀링 방식으로 지속적으로 호출 하기도하며
레디스의 TTL, Sorted Set 등을 이용할 수 있는 대기열만 일단 Redis 로 전환 하기로 하였다.

그 이상은 오버엔지니어링 일 것같고, 사실 대기열 또한 현재레벨에서는 불필요 할 수 있으나
h2 제외한 모든 DB와 비교해서 우수한 성능을 자랑하기 때문에 대기열을 레디스로 전환하기로 판단하였다.

#### Embedded Redis

흔히 레디스를 로컬 혹은 도커로 실행하지만
운영단계가 아닌 간단한 테스트 및 프로젝트 클론시에도 사용 할 수 있도록
임베디드 레디스를 채택하였다.
물론 도커환경에서 도입 하면 더 수월하게 레디스를 사용할 수 있다.

```java
// Redis (Embedded)
implementation group: 'com.github.codemonstur', name: 'embedded-redis', version: '1.4.3';
implementation("org.springframework.boot:spring-boot-starter-data-redis");
```
다음 의존성을 추가해주었다. 현재는 'com.github.codemonstur' 라는 곳에서 해당 프로젝트를 포크하여 이어나가고 있다고 한다.
JPA 형식을 닮은 RedisRepository 방식과 RedisTemplate 방식중 후자를 선택하였다.
전자는 너무 JPA 종속적인 느낌이 강했다.

대기열을 DB -> 레디스로 변경하면서 서비스와 필터, 테스트 코드등 많은 부분을 수정하게 되었다.
지난 1주차 부터 강조 되었던 인프라에 의존적이지 않은, DIP 잘된 코드라면
수정점이 크지 않았을 텐데, 수정점이 매우 많아서 다시한번 클린 아키텍처에 대해 생각 하게 되었다.

### 성능비교

시간관계상 많은 성능 비교를 하지 못하였으나, 

결과론 적으론 
Redis Vs H2 중 비슷하거나 Redis 가 성능이 조금 더 좋았으며
Redis Vs MySQL 시 Redis 가 눈에 띄게 성능이 더 좋았다.

1000명의 유저가 10초 동안 요청을 보낸다고 가정하였고, 툴로는 K6, grafana를 사용하였다.

![Redis Vs H2](https://velog.velcdn.com/images/saruru/post/7b13c5c9-f069-438a-8eba-c89cb5f31b9c/image.png)
같은 부하의 요청에서도 전자 의 redis 는 빨리성능을 회복하지만, h2는 상대적으로 느리게 회복 되었다.

![Redis Vs MySQL](https://velog.velcdn.com/images/saruru/post/f169fd95-e6a2-49ef-adda-e8a9708bbc07/image.png)
성능차이는 레디스와 MySQL 에서 특히 심하게 벌어지는데, 그래프만을 보아도 레디스는 부하가 발생 뒤 빠른 처리로 급격하게 줄어드는 방면,
MySQL 의 경우 요청 이후 바로 처리가 끝나지 못하고 일정시간 부하가 유지되는 모습이다.

해당 테스트로는 크게 와닿지 않아 비교되는 정보를 찾아보았다.

### MySQL과 성능 비교
레디스는 MySQL에 비해 성능 면에서 크게 우수하다. 
MySQL은 디스크 기반 데이터베이스이므로 디스크 I/O가 발생하고, 데이터 크기가 커지면 성능이 급격히 저하될 수 있다.
반면, 레디스는 메모리 기반으로 동작하여 디스크 I/O를 줄일 수 있기 때문에 더 빠른 데이터 접근 속도를 제공한다.

읽기 속도: 레디스는 메모리에서 바로 데이터를 읽어오기 때문에 MySQL보다 훨씬 빠르다.
쓰기 속도: 레디스는 메모리에 데이터를 먼저 쓰고 비동기 방식으로 디스크에 저장하는 방식이라 쓰기 속도도 빠르다. MySQL은 디스크에 데이터를 바로 쓰기 때문에 속도가 상대적으로 느리다.

#### 마치며...
성능이외에도 레디스를 쓰면서 편했던 것이 TTL 을 통한 스케쥴러없이 자동 만료 시킬 수 있는 점이였다.
후에 배울 Kafka 와의 궁합도 상당히 좋은 편이라고 알고있다.

다만 이러한 장점 이면에는 높은 러닝커브 또한 레디스의 단점이였다.
생소한 자료구조와 전통적인 RDBMS의 쿼리의 부재, 컬럼과 대응 되는 밸류를 저장함에 있어서의 번거로움 등이 존재했다.
또한 같이 개발하는 사람들 중 레디스의 특징을 모른다면 크게 곤란한 상황이 올 것이다.

과도한 오버엔지니어링을 경계 하고, RDBMS 를 사용하다가 큰 서버비용 및 느린 속도가 체감이 될 때에 레디스를 도입 하면 좋겠다고 생각했다.
정말 편한 기술이지만 사실 큰 트래픽을 예상에서 미리 캐시 까지 준비 하는건 오버 엔지니어링일 수 있겠다는 생각도 든 과제였다.

