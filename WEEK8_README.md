 <aside>
💡 아래 명세를 잘 읽어보고, 서버를 구현합니다.

</aside>

## Description

- **`콘서트 예약 서비스`**를 구현해 봅니다.
- 대기열 시스템을 구축하고, 예약 서비스는 작업가능한 유저만 수행할 수 있도록 해야합니다.
- 사용자는 좌석예약 시에 미리 충전한 잔액을 이용합니다.
- 좌석 예약 요청시에, 결제가 이루어지지 않더라도 일정 시간동안 다른 유저가 해당 좌석에 접근할 수 없도록 합니다.

<aside>
🗓️ **Weekly Schedule Summary: 이번 챕터의 주간 일정 (금요일 오전 10시까지 제출)**

</aside>

### 8주차 과제

### **`STEP 15_기본`**

- 나의 시나리오에서 수행하는 쿼리들을 수집해보고, 필요하다고 판단되는 인덱스를 추가하고 쿼리의 성능개선 정도를 작성하여 제출
    - 자주 조회하는 쿼리, 복잡한 쿼리 파악
    - Index 추가 전후 Explain, 실행시간 등 비교

### **`STEP 16_심화`**

- 내가 개발한 기능의 트랜잭션 범위에 대해 이해하고, 서비스의 규모가 확장된다면 서비스들을 어떻게 분리하고 그 분리에 따른 트랜잭션 처리의 한계와 해결방안에 대한 서비스설계 문서 작성
- 실시간 주문, 좌석예약 정보를 데이터 플랫폼에 전달하거나 이력 데이터를 저장 ( 외부 API 호출, 메세지 발행 등 ) 하는 요구사항 등을 기존 로직에 추가해 보고 기존 로직에 영향 없이 부가 기능을 제공

# STEP 15

## DB (MySQL) & 인덱싱

- 이번주차에는 나의 콘서트 예약 앱에서 자주 조회하는 쿼리, 복잡한 쿼리를 파악 후에 동시 다발적인 요청이 들어 왔을 때, 어떻게 효과적으로 처리 할 수 있을지 고민 하는 시간을 가진다.
- 이때, 가장 효과적으로 수행시간을 줄일 수 있는 쿼리 Index 에 대해 알아보고, 직접 적용 후 실행시간을 비교 해 보기로 한다.

### 나의 DB 환경
- Test 및 로컬 DB: H2
- 개발 및 운영 DB: MySQL
- 대기열 큐: Redis

다음과 같이 운용할 계획이기 때문에 MySQL 을 기준으로 작성하도록 한다.

### 1. MySQL 주요기능 - MVCC

innoDB를 채택한 MySQL 버전의 경우 MVCC 기능을 이용 할 수 있다.
mvcc 개념은 6주차에 기록했던 내용을 첨부한다.


#### MVCC (Multi-Version Concurrency Control)
> - `개념`: MVCC는 다중 버전 동시성 제어로, 트랜잭션 간의 데이터 충돌 없이 데이터의 여러 버전을 동시에 유지하여 읽기 작업과 쓰기 작업의 충돌을 피하는 방법.
> - `구현`: MVCC에서는 데이터를 변경할 때, 기존 데이터를 즉시 삭제하거나 덮어쓰지 않고 새로운 버전을 생성.
각 트랜잭션은 자신의 작업이 시작된 시점의 데이터 버전을 유지하면서 작업을 진행.
이를 통해 읽기 트랜잭션과 쓰기 트랜잭션이 동시에 수행될 수 있으며, 읽기 작업은 자신의 트랜잭션 시점의 데이터를 볼 수 있어 충돌이 발생하지 않는다.
> - `특징`:
>   - Read Consistency: 트랜잭션이 시작된 시점의 데이터 버전을 사용해 일관된 결과를 제공한다.
>   - 성능 향상: 읽기와 쓰기를 구분해 충돌을 방지함으로써 트랜잭션의 동시성을 크게 개선할 수 있다.
>   - Garbage Collection: 오래된 데이터 버전은 이후에 삭제되거나 정리.
> - `장점`: 
>   - 읽기 트랜잭션이 락 없이 작업할 수 있어 성능이 높고, 높은 동시성을 제공. 
>   - 데이터 충돌이 적은 경우 성능 향상이 크며, 읽기 작업이 많은 시스템에서 매우 유용하다.
> - `단점`: 데이터 버전을 관리하는 오버헤드가 발생하며, 자주 변경되는 데이터에 대해 오래된 버전을 유지하면 스토리지 사용이 증가한다.


### 2. PK vs Index
이전가지 막연히 PK 지정시 Index 가 생성되며, PK 를 이용한 조회조건 설정 시 쿼리 성능이 향상 된다고만 알고 있었다. PK 지정을 통한 Index와  임의로 생성한 Index 와 어떤차이와 장단점이 있는지 확인 해 보았다.

> INDEX?
>- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
>- 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상 됨
>
>*장점*
>- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
>- 전반적인 시스템의 부하를 줄일 수 있다.
>
>*단점*
>- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
>- 인덱스를 관리하기 위해 추가 작업이 필요하다.
>- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
>
>*Index를 활용하면 좋을 경우* 
>- 규모가 작지 않은 테이블
>- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
>- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
>- 데이터의 중복도가 낮은 컬럼

> PK 의 특징
>- PK는 레코드의 저장 위치를 결정한다.
>- PK는 NOT NULL과 유니크 속성을 가진다.
>- MySQL에서는 PK 기준으로 유사한 값들이 묶여 저장되며, 이를 클러스터링이라 부른다.
>- 일반적으로 PK는 클러스터 인덱스라고 불린다.
>- 레코드를 저장하거나 PK를 변경할 때 처리 속도가 느려질 수 있다.
>- 일반 인덱스는 논클러스터 인덱스로 불린다.
>- PK가 레코드의 물리적 저장 위치를 결정하기 때문에 인덱스는 PK에 의존한다.

> 클러스터링 Index(PK) 의 장단점
>
>*장점*
>- PK로 검색할 때 처리가 매우 빠름
>- 연속되는 PK로 조회할 경우 랜덤 I/O가 아닌 순차 I/O를 사용하여 처리 속도가 더욱 빠름
>- 인덱스가 PK값을 가지므로 인덱스로 PK 값만 조회하는 경우 효율적으로 처리될 수 있음(=커버링 인덱스)
>
>*단점*
>- 모든 인덱스가 PK에 의존하므로 PK 값이 클 경우 전체적으로 인덱스의 크기가 커지고, 페이지 양이 많아짐
>- 인덱스를 통해 검색할 때 PK로 다시 한번 검색해야 하므로 처리 성능이 느림
>- INSERT 시에 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
>- PK를 변경할 때 레코드를 DELETE 및 INSERT 해야 하므로 처리 성능이 느림



